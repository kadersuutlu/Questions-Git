1- Git nedir?
Git, yazılım geliştirme sürecinde kullanılan bir versiyon kontrol sistemi olarak tanımlanabilir. Bu sistem, bir proje üzerinde yapılan değişikliklerin izlenmesine, yönetilmesine ve işbirliği yapılmasına olanak sağlar. Geliştiriciler, Git'i kullanarak kodları depolayabilir, değişiklikleri takip edebilir, farklı versiyonlar arasında geçiş yapabilir ve ekip üyeleriyle birlikte çalışabilirler. Git, dağıtık bir yapıya sahiptir, yani her kullanıcı kendi kopyasını alır ve bağımsız olarak çalışabilir, daha sonra değişiklikleri birleştirebilir. Bu, paralel geliştirme yapmayı kolaylaştırır ve projelerin daha düzenli bir şekilde yönetilmesine olanak tanır.
**********************************
2- "git pull" ile "git fetch" komutlarının farkı nedir?
"git pull" ve "git fetch" komutları, uzak bir Git deposundan değişiklikleri yerel depoya almanın iki farklı yolunu temsil eder.

git fetch: Bu komut, uzak depodaki değişiklikleri yerel depoya getirir, ancak bu değişiklikleri yerel çalışma dizinine birleştirmez. Yani, uzaktaki güncellemeleri yerel depoya indirir, ancak yerel dosyaları etkilemez. Bu, yerel deponun güncel olup olmadığını kontrol etmenizi sağlar ve güncelleme işlemini istediğiniz zaman gerçekleştirebilirsiniz.
git pull: Bu komut, aslında iki işlemi birleştirir: "git fetch" ve "git merge" veya "git rebase". Yani, önce uzaktaki değişiklikleri yerel depoya getirir (git fetch gibi), ardından yerel çalışma dizinindeki değişikliklerle birleştirir veya yeniden temel alır. Böylece, "git pull" komutunu kullandığınızda, hem uzak değişiklikler indirilir hem de yerel çalışma dizininde birleştirme işlemi otomatik olarak gerçekleştirilir. Bu, tek bir adımda uzak değişiklikleri alıp, yerel çalışma dizinindeki kodunuzu güncellemenize olanak tanır.
**********************************
3- Eğer takım arkadaşımız "kodlarımı gönderdim, benim geliştirmemin üzerine devam et" derse ve gönderdiği kodları "git pull" ile lokalimize alamıyorsak nerelerde hata yapılmış olabilir?
Uzak depo bağlantısı eksik veya hatalı: İlk olarak, uzak depoya erişimde bir sorun olabilir. Örneğin, doğru uzak depo URL'si belirtilmemiş olabilir veya erişim izinleri hatalı olabilir.
Uzak depo güncel değil: Takım arkadaşınızın kodlarını gönderdiği depo güncel değilse, "git pull" komutu çalışmaz çünkü uzak depoda alınacak bir şey yoktur.
Kodlar gönderilmedi veya yanlış depoya gönderildi: Takım arkadaşınızın kodları hiç gönderilmediyse veya yanlış bir depoya gönderildiyse, "git pull" komutu işe yaramaz çünkü uzak depoda alınacak bir değişiklik yoktur.
Bağlantı sorunları: İnternet bağlantısında veya ağ erişiminde genel bir sorun olabilir, bu da uzak depodan veri almanızı engelleyebilir.
**********************************
4- "git fetch origin" komutundaki "origin" neye karşılık gelmektedir?
"origin", bir Git depo bağlantısının adıdır. Genellikle, yerel depoya bağlı bir veya birden fazla uzak depo olduğunda, her uzak depo bağlantısına bir ad verilir. Bu ad, uzak depoyu tanımlamak için kullanılır ve genellikle varsayılan olarak "origin" olarak adlandırılır.

"origin" adı, bir uzak depo bağlantısını belirtir ve bu bağlantı genellikle depoyu barındıran hizmetin adını temsil eder. Örneğin, GitHub'da barındırılan bir projede, "origin" adı genellikle GitHub reposunu temsil eder. Ancak, "origin" adı her zaman GitHub olmak zorunda değildir; projenin barındırıldığı başka bir hizmetin adı da olabilir.

Yani, "git fetch origin" komutu, yerel depoya bağlı olan "origin" adlı uzak depodan değişiklikleri getirir. Bu komut, yerel depoya bağlı olan uzak depolar arasında belirtilen "origin" adlı uzak depoyu hedef alır ve bu depodan güncellemeleri alır.
**********************************
5- "HEAD" kelimesi neyi temsil etmektedir?
"HEAD", Git deposundaki mevcut işlem gören dalı veya bağlı olan son taahhütü (commit) temsil eder. Yani, "HEAD", şu anda çalışılan dalı veya projenin en son durumunu gösterir.

Git'te "HEAD" kavramı, iki farklı bağlamda kullanılır:

Branch İsimleri ile: Eğer mevcut olarak hangi dalda olduğunuzu görmek istiyorsanız, "HEAD" o dalın son taahhüdünü temsil eder. Örneğin, eğer "master" dalındaysanız, "HEAD" "master" dalının en son taahhüdünü gösterir.
Commit İdentifikatörleri ile: Eğer belirli bir taahhüd (commit) üzerinde çalışıyorsanız, "HEAD" o commit'i temsil eder. Bu durumda, "HEAD" belirli bir commit'in SHA-1 kimlik numarasını gösterir.
Genel olarak, "HEAD" terimi, mevcut işlem gören dalı veya taahhüdü temsil etmek için kullanılır ve Git deposunun mevcut durumunu belirtir.
**********************************
6- "Staging Area" ya da "Index" diye isimlendirilen bölge tam olarak ne demektir?
"Staging Area" veya "Index", Git'in iş akışında önemli bir konsepttir. Bu terim, Git deposundaki dosyaların taahhüt (commit) öncesindeki durumunu belirtir.

Staging Area, değişikliklerin geçici olarak saklandığı bir bölgedir. Bir dosyayı değiştirdiğinizde veya yeni bir dosya eklediğinizde, bu değişiklikler otomatik olarak taahhüd edilmez. Bunun yerine, değişiklikler önce Staging Area'ya eklenir. Bu, değişikliklerin bir sonraki taahhüde dahil edilip edilmeyeceğini belirleme imkanı verir.

Staging Area'nın kullanılmasının avantajları şunlardır:

Kontrol ve İnceleme: Değişiklikler, taahhüt öncesi bir aşamada incelenebilir ve gerektiğinde düzenlenebilir.
Bölümlü Taahhüt: Farklı dosyaları ayrı ayrı taahhüt etmek istediğinizde, bu değişiklikleri önce Staging Area'ya ekleyerek dosyaları gruplayabilirsiniz.
Dikkatli Taahhüt: İstenmeyen değişikliklerin taahhüt edilmesini önlemek için, sadece istenilen değişiklikler Staging Area'ya eklenir.
Bu nedenle, Staging Area veya Index, Git kullanıcılarına dosyaları taahhüt etmeden önce değişiklikler üzerinde kontrol sağlar ve dosyaların düzenli bir şekilde taahhüt edilmesini sağlar.
**********************************
7- "Untracked file" ne demektir?

"Untracked file" terimi, Git deposu tarafından izlenmeyen ve takip edilmeyen bir dosyayı ifade eder. Yani, bu dosya, Git tarafından bilinmeyen veya kontrol altına alınmamıştır.

Bir dosya genellikle üç durumda olabilir:

İzlenen (Tracked): Bu dosyalar, zaten depoya eklenmiş ve Git tarafından izlenmektedir. Değişiklikleri takip edilir ve taahhütlere dahil edilebilirler.
Staged: Değişiklikler Staging Area'ya eklenmiş, ancak henüz taahhüt edilmemiş dosyalardır. Bir sonraki taahhütte bu değişiklikler dahil edilir.
Untracked: Bu dosyalar, depoya henüz eklenmemiş veya izlenmeye başlanmamış dosyalardır. Yani, Git bu dosyaları tanımaz ve değişiklikleri takip etmez.
"Untracked file" durumu genellikle yeni oluşturulan dosyalar veya depoya eklenmemiş dosyalar için geçerlidir. Bu dosyalar, genellikle projeye yeni eklenen veya geçici dosyalardır. Git, bu dosyaları otomatik olarak izlemez veya takip etmez, bu nedenle kullanıcılar bu dosyaları açıkça eklemelidir. Bu, "git add" komutu ile yapılabilir. Bu şekilde, dosyalar Staging Area'ya eklenir ve bir sonraki taahhütte dahil edilirler.
**********************************
8- ".git" klasörünü silersek ne olur?
".git" klasörü, Git deposunun tüm tarihçesini, dallarını, taahhütlerini ve yapılandırma bilgilerini içeren önemli bir klasördür. Bu klasörün silinmesi ciddi sonuçlara yol açar ve Git deposunun işlevselliğini büyük ölçüde etkiler.

Eğer ".git" klasörünü silerseniz:

Tarihçe ve Taahhütler Kaybolur: ".git" klasörü, Git deposunun tüm geçmişini barındırır. Bu klasör silindiğinde, tüm taahhüt geçmişi kaybolur ve geçmişte yapılan değişiklikler geri getirilemez.
Dallar Kaybolur: Git deposundaki dallar ve bu dallara yapılan tüm değişiklikler de silinir. Bu, projenin mevcut durumunu ve farklı geliştirme dallarını tamamen kaybedeceğiniz anlamına gelir.
Yapılandırma Bilgileri Kaybolur: ".git" klasörü, Git deposunun yapılandırma bilgilerini içerir. Bu, özel ayarlar, uzak depo bağlantıları ve diğer yapılandırma ayarlarını içerir. ".git" klasörünün silinmesiyle, bu yapılandırma bilgileri de kaybolur.
Depo Geri Dönüşsüz Olarak Hasar Görür: ".git" klasörünü silmek, depoya geri dönüşsüz zarar verir. Bu nedenle, bu klasörün silinmesi, Git deposunun tamamen kullanılamaz hale gelmesine neden olur.
Bu nedenle, ".git" klasörünü silmek, Git deposunun işlevselliğini kaybetmenize ve projenin tüm geçmişini ve yapılandırma bilgilerini kaybetmenize neden olur. Bu, ciddi bir sorun oluşturur ve kesinlikle kaçınılması gereken bir durumdur.
**********************************
9- Kendi lokalimizde her "git init" komutunu kullanıdığımızda otomatik olarak "ReadMe.md" dosyası oluşturulmasını istiyorsak ne yapmalıyız?
Kendi lokalimizde her "git init" komutunu kullandığımızda otomatik olarak "README.md" dosyasının oluşturulmasını istiyorsak, birkaç adımla bunu sağlayabiliriz:

İlk olarak, bir "README.md" dosyası oluşturun ve içeriğini hazırlayın. Bu dosya, proje hakkında genel bilgi ve talimatlar içerebilir.
Ardından, bu dosyayı herhangi bir yeni proje dizininde varsayılan olarak oluşturmak için Git'in şablon dosyalarını yapılandıracağız.
Komut satırını kullanarak, Git'in kullanacağı şablon dizinine gitmek için aşağıdaki komutu çalıştırın:
cd /usr/share/git-core/templates
Windows'ta bu konum biraz farklı olabilir, bu yüzden uygun konuma gidin.

"templates" dizini altında bir "init" dizini oluşturun:
mkdir init
"init" dizini altına girin:
cd init
Burada, "README.md" dosyasını oluşturun ve içeriğini kopyalayın:
touch README.md   veya   echo "# My Project" >> README.md
Bu, "README.md" dosyasını oluşturur ve içine "# My Project" başlığını ekler. Başlığı kendi projenizin adıyla değiştirebilirsiniz.

Artık herhangi bir yeni proje oluşturduğunuzda, "git init" komutunu kullandığınızda, otomatik olarak bir "README.md" dosyası oluşturulacak ve içeriği "My Project" başlığıyla dolu olacaktır. Bu dosya, projenizle ilgili temel bilgileri sağlamak için kullanılabilir.
**********************************
10- Git konusunda bahsi geçen "branch" yapısı nedir? Bize ne sağlar?
Git'te "branch", projenin farklı geliştirme yolaklarını temsil eden ve aynı anda farklı değişiklikler üzerinde çalışılmasını sağlayan bir yapıdır. Bir "branch" (dal), projenin mevcut durumunu (genellikle "master" veya "main" olarak adlandırılan ana dal) kopyalar ve üzerinde bağımsız olarak çalışmayı mümkün kılar. Her bir dal, projenin farklı bir yönünü temsil eder ve projenin gelişimini izlemek ve yönetmek için kullanılır.

"Branch" yapısı, birçok fayda sağlar:

Paralel Geliştirme: Farklı geliştiriciler veya aynı geliştirici farklı özellikler üzerinde aynı anda çalışabilir. Her bir geliştirici kendi dalında değişiklikler yapabilir ve bu değişiklikleri ana dala entegre etmeden önce test edebilir.
Deneysel Geliştirme: Yeni özellikler veya değişiklikler üzerinde çalışırken, deneysel dallar oluşturabilir ve bu dallarda değişiklikleri test edebilirsiniz. Ana dala entegre etmeden önce deneysel dalları kullanarak değişiklikleri deneyebilirsiniz.
Sürüm Yönetimi: Farklı sürümleri veya sürüm adaylarını temsil etmek için dallar oluşturabilirsiniz. Her bir dal, bir sürüm veya sürüm adayını temsil edebilir ve sürüm yönetimini daha organize bir şekilde yönetmenize olanak tanır.
Hata Düzeltme: Ana daldaki bir hata üzerinde çalışırken, hızlıca bir hata düzeltme dalı oluşturabilir ve bu dalda hata düzeltmeleri yapabilirsiniz. Bu, ana daki hata üzerinde çalışmayı etkilemeden hızlıca hata düzeltmeleri yapmanıza olanak tanır.
İzolasyon ve Güvenlik: Dallar, değişikliklerinizi izole ederek ana daldaki diğer geliştirme çalışmalarından etkilenmeden çalışmanızı sağlar. Ayrıca, bir dalda yapılan değişiklikler diğer daları etkilemez, bu da güvenli bir geliştirme ortamı sağlar.
Bu nedenlerle, "branch" yapısı, geliştirme sürecini organize etmek, paralel geliştirme yapmak ve değişiklikleri yönetmek için güçlü bir araçtır.
**********************************
11- Sıfırdan bir "branch" nasıl oluşturabiliriz?
Git'te sıfırdan bir dal (branch) oluşturmak oldukça basittir. İşte adımlar:

İlk olarak, projenizin kök dizinine gidin. Bu, Git deposunun bulunduğu dizindir.
Ardından, yeni bir dal oluşturmak için aşağıdaki komutu kullanın:
git branch yeni_dal_adı
Örneğin, bir "feature" dalı oluşturmak istiyorsanız:
git branch feature
Bu komut, "yeni_dal_adı" olarak adlandırılan bir dal oluşturur, ancak bu dal üzerine geçiş yapmaz. Yani, şu anda hala mevcut dalda (genellikle "master" veya "main" olarak adlandırılır) kalırsınız.

Oluşturduğunuz yeni dalda çalışmaya başlamak için, oluşturduğunuz dala geçiş yapmanız gerekmektedir. Geçiş yapmak için aşağıdaki komutu kullanın:
git checkout yeni_dal_adı
Örneğin:
git checkout feature
Bu komut, yeni oluşturduğunuz dala geçiş yapar ve artık bu dalda çalışırsınız.

Artık "feature" adında bir dal oluşturmuş oldunuz ve bu dal üzerinde çalışmaya başlayabilirsiniz. Bu dalı oluşturduktan ve üzerine geçiş yaptıktan sonra, değişikliklerinizi bu dala ekleyebilir ve bu dala taahhütler yapabilirsiniz.
**********************************